# Security Code Review

**Date:** 2026-01-21
**Reviewer:** Claude Opus 4.5
**Scope:** Full security review of Go codebase

## Executive Summary

The `start` CLI orchestrator demonstrates a security-conscious design with proper command injection prevention through shell escaping, safe path handling with tilde expansion, and appropriate file permission practices. No critical or high severity vulnerabilities were identified. The codebase follows secure coding practices appropriate for a local CLI tool.

**Severity Counts:**
- Critical: 0
- High: 0
- Medium: 2
- Low: 3
- Informational: 4

## Dependency Security

### govulncheck Results

```
No vulnerabilities found.
```

All dependencies are current with no known CVEs. The `go.sum` file is committed, ensuring reproducible builds with verified dependencies.

### Dependencies Reviewed

| Package | Version | Assessment |
|---------|---------|------------|
| cuelang.org/go | v0.15.1 | Latest stable, no known issues |
| github.com/spf13/cobra | v1.10.2 | Latest stable, widely used CLI framework |
| github.com/fatih/color | v1.18.0 | Latest stable, simple colour output |
| golang.org/x/term | v0.36.0 | Standard extended library |

---

## Findings

### Medium Severity

#### M-001: Command Template Injection via Malicious CUE Configuration

**Location:** `internal/orchestration/executor.go:118-167`

**Description:** The agent command template is read from CUE configuration and executed via shell. While `escapeForShell()` properly escapes placeholder values (prompts, roles, model names), the command template itself comes from configuration which could be maliciously crafted if an attacker can modify the configuration files.

**Risk:** If an attacker gains write access to `~/.config/start/` or `.start/`, they could inject arbitrary shell commands via the `command` field in agent configuration.

**Mitigating Factors:**
- Configuration directories use standard file permissions (0755 for directories, 0644 for files)
- Requires local filesystem access to exploit
- This is by design - the tool is meant to execute arbitrary AI CLI commands

**Recommendation:** This is an accepted risk for a CLI orchestration tool. Consider documenting that configuration files should be treated as trusted code and protected accordingly. The `doctor` command could optionally check configuration file permissions.

---

#### M-002: Shell Command Execution via UTD `command` Field

**Location:** `internal/orchestration/template.go:125-129`, `internal/shell/runner.go:46-132`

**Description:** The UTD (Unified Template Definition) system allows contexts, roles, and tasks to specify a `command` field that is executed via shell to generate content. This command output becomes part of prompts sent to AI agents.

**Risk:** Malicious registry packages could contain harmful shell commands. While the tool fetches packages from the CUE Central Registry, there's no sandboxing of command execution.

**Mitigating Factors:**
- Users explicitly install packages via `start assets add`
- Commands run with user's privileges, not elevated
- 30-second timeout prevents runaway processes (`shell.DefaultTimeout`)
- Process groups are used for clean termination on timeout

**Recommendation:** Consider adding a `--dry-run` equivalent for asset installation that shows what commands would be executed. Document that installing packages from the registry is equivalent to running arbitrary code.

---

### Low Severity

#### L-001: Error Messages May Reveal Internal Paths

**Location:** Multiple locations in error handling

**Description:** Error messages include full filesystem paths (e.g., `/Users/username/.config/start/agents.cue`). While useful for debugging, this reveals username and system structure.

**Mitigating Factors:**
- CLI tools are inherently local; the user already has access to their own filesystem
- The `shortenPath()` function in `internal/doctor/checks.go:435-444` uses `~` abbreviation in some contexts

**Recommendation:** Low priority. The path disclosure is consistent with standard CLI tool behaviour and aids debugging. No action required.

---

#### L-002: Temp Files Use Predictable Names

**Location:** `internal/temp/manager.go:36-57`, `internal/temp/manager.go:104-126`

**Description:** Temporary files use predictable naming patterns:
- Dry-run: `/tmp/start-YYYYMMDDHHmmss/`
- UTD: `.start/temp/{type}-{sanitised-name}.md`

**Mitigating Factors:**
- File permissions are restrictive (0600 for files, 0755 for directories)
- Files contain prompts/roles, not credentials
- Collision handling exists for dry-run directories

**Recommendation:** The current implementation is acceptable for the threat model. File permissions are correctly restrictive.

---

#### L-003: Registry Module Paths Not Validated

**Location:** `internal/registry/client.go:47-77`

**Description:** Module paths from the registry index are used directly to fetch packages. While the CUE registry infrastructure handles validation, there's no additional path sanitisation in the client.

**Mitigating Factors:**
- Uses official CUE `modconfig.Registry` implementation
- Module paths come from the start-assets index, not user input
- CUE's module resolution handles path validation

**Recommendation:** Current implementation relies appropriately on CUE's built-in security. No action required.

---

### Informational

#### I-001: Good Practice - Shell Escaping Implementation

**Location:** `internal/orchestration/executor.go:279-285`

**Observation:** The `escapeForShell()` function correctly implements single-quote escaping to prevent command injection:

```go
func escapeForShell(s string) string {
    escaped := strings.ReplaceAll(s, "'", "'\"'\"'")
    return "'" + escaped + "'"
}
```

This is the correct approach - wrapping in single quotes and escaping internal single quotes by ending the quoted section, adding a double-quoted literal quote, and resuming the single-quoted section.

---

#### I-002: Good Practice - Path Traversal Prevention

**Location:** `internal/orchestration/composer.go:79-96`

**Observation:** The `isLocalFile()` function correctly validates that file paths remain within the working directory:

```go
func (c *Composer) isLocalFile(filePath string) bool {
    // Relative paths are local
    if !filepath.IsAbs(filePath) {
        return true
    }
    // Absolute paths are local if they're under the working directory
    cleanPath := filepath.Clean(filePath)
    cleanWorkDir := filepath.Clean(c.workingDir)
    return strings.HasPrefix(cleanPath, cleanWorkDir+string(filepath.Separator))
}
```

Uses `filepath.Clean()` to normalise paths, preventing `../` traversal attacks.

---

#### I-003: Good Practice - Tilde Expansion Before Shell Execution

**Location:** `internal/orchestration/executor.go:27-45`

**Observation:** The code correctly expands `~` in paths before quoting for shell execution, since shells don't expand tilde within single quotes:

```go
func expandTilde(path string) string {
    if len(path) > 1 && path[0] == '~' && path[1] == '/' {
        if home, err := os.UserHomeDir(); err == nil {
            return home + path[1:]
        }
    }
    return path
}
```

---

#### I-004: Good Practice - Template Validation

**Location:** `internal/orchestration/executor.go:87-116`

**Observation:** `ValidateCommandTemplate()` proactively checks for common template errors:
- Detects quoted placeholders that would cause double-quoting
- Detects wrong placeholder syntax (`{name}` vs `{{.name}}`)

This prevents users from creating insecure templates accidentally.

---

## Areas Not Applicable

The following security areas from the review checklist are not applicable to this codebase:

### Authentication and Authorisation
This is a local CLI tool without network services or multi-user access. No authentication is required.

### HTTP Security
The tool does not serve HTTP. It only makes outbound requests to the CUE registry using standard Go HTTP client.

### Cryptography
No cryptographic operations are performed. The tool doesn't handle encryption, key generation, or certificate validation directly.

### Data Protection
No sensitive user data (passwords, PII) is processed. Prompts and roles are text content provided by the user.

### SQL Injection
No database interactions.

### CSRF/XSS
No web interface.

---

## Recommendations Summary

| ID | Severity | Recommendation | Priority |
|----|----------|----------------|----------|
| M-001 | Medium | Document that config files should be protected like code | Low |
| M-002 | Medium | Consider dry-run for asset installation showing commands | Medium |
| L-001 | Low | No action required | - |
| L-002 | Low | No action required | - |
| L-003 | Low | No action required | - |

---

## Conclusion

The `start` CLI tool demonstrates security-conscious design appropriate for its threat model as a local command-line utility. The command injection mitigations via `escapeForShell()` are correctly implemented, and path handling uses proper sanitisation with `filepath.Clean()`.

The primary security consideration is that this tool executes shell commands from configuration and registry packages by design. This is an inherent property of a CLI orchestrator and is appropriately documented. Users should treat configuration files and installed packages with the same trust level as executable code.

No code changes are required. Documentation enhancements around the trust model for configuration and registry packages would be beneficial.
