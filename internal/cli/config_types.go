package cli

import (
	"errors"
	"fmt"
	"os"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"github.com/grantcarthew/start/internal/config"
	internalcue "github.com/grantcarthew/start/internal/cue"
)

// AgentConfig represents an agent configuration for editing.
type AgentConfig struct {
	Name         string
	Bin          string
	Command      string
	DefaultModel string
	Description  string
	Models       map[string]string
	Tags         []string
	Source       string // "global" or "local" - for display only
	Origin       string // Registry module path when installed from registry
}

// loadAgentsForScope loads agents from the appropriate scope.
// Returns the agents map, names in definition order, and any error.
func loadAgentsForScope(localOnly bool) (map[string]AgentConfig, []string, error) {
	return loadForScope(localOnly, loadAgentsFromDir, func(a *AgentConfig, s string) { a.Source = s })
}

// loadAgentsFromDir loads agents from a specific directory.
// Returns the agents map, names in definition order, and any error.
func loadAgentsFromDir(dir string) (map[string]AgentConfig, []string, error) {
	agents := make(map[string]AgentConfig)
	var order []string

	loader := internalcue.NewLoader()
	cfg, err := loader.LoadSingle(dir)
	if err != nil {
		// If no CUE files exist, return empty map (not an error)
		if errors.Is(err, internalcue.ErrNoCUEFiles) {
			return agents, order, nil
		}
		return agents, order, err
	}

	agentsVal := cfg.LookupPath(cue.ParsePath(internalcue.KeyAgents))
	if !agentsVal.Exists() {
		return agents, order, nil
	}

	iter, err := agentsVal.Fields()
	if err != nil {
		return nil, nil, fmt.Errorf("iterating agents: %w", err)
	}

	for iter.Next() {
		name := iter.Selector().Unquoted()
		val := iter.Value()

		agent := AgentConfig{Name: name}

		if v := val.LookupPath(cue.ParsePath("bin")); v.Exists() {
			agent.Bin, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("command")); v.Exists() {
			agent.Command, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("default_model")); v.Exists() {
			agent.DefaultModel, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("description")); v.Exists() {
			agent.Description, _ = v.String()
		}

		agent.Tags = extractTags(val)

		// Load models
		if modelsVal := val.LookupPath(cue.ParsePath("models")); modelsVal.Exists() {
			agent.Models = make(map[string]string)
			modelIter, err := modelsVal.Fields()
			if err == nil {
				for modelIter.Next() {
					alias := modelIter.Selector().Unquoted()
					if s, err := modelIter.Value().String(); err == nil {
						agent.Models[alias] = s
					}
				}
			}
		}

		// Load origin (registry provenance)
		if v := val.LookupPath(cue.ParsePath("origin")); v.Exists() {
			agent.Origin, _ = v.String()
		}

		agents[name] = agent
		order = append(order, name)
	}

	return agents, order, nil
}

// writeAgentsFile writes the agents configuration to a file.
// Agents are not order-dependent, so names are sorted alphabetically for consistent output.
func writeAgentsFile(path string, agents map[string]AgentConfig) error {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by start config\n")
	sb.WriteString("// Edit this file to customize your agent configuration\n\n")
	sb.WriteString("agents: {\n")

	// Sort agent names for consistent output
	var names []string
	for name := range agents {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		agent := agents[name]
		sb.WriteString(fmt.Sprintf("\t%q: {\n", name))

		// Write origin first if present (registry provenance)
		if agent.Origin != "" {
			sb.WriteString(fmt.Sprintf("\t\torigin: %q\n", agent.Origin))
		}
		if agent.Bin != "" {
			sb.WriteString(fmt.Sprintf("\t\tbin:     %q\n", agent.Bin))
		}
		if agent.Command != "" {
			sb.WriteString(fmt.Sprintf("\t\tcommand: %q\n", agent.Command))
		}

		if agent.DefaultModel != "" {
			sb.WriteString(fmt.Sprintf("\t\tdefault_model: %q\n", agent.DefaultModel))
		}
		if agent.Description != "" {
			sb.WriteString(fmt.Sprintf("\t\tdescription: %q\n", agent.Description))
		}
		writeCUETags(&sb, agent.Tags)
		if len(agent.Models) > 0 {
			sb.WriteString("\t\tmodels: {\n")
			var aliases []string
			for alias := range agent.Models {
				aliases = append(aliases, alias)
			}
			sort.Strings(aliases)
			for _, alias := range aliases {
				sb.WriteString(fmt.Sprintf("\t\t\t%q: %q\n", alias, agent.Models[alias]))
			}
			sb.WriteString("\t\t}\n")
		}

		sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// loadConfigForScope loads the settings.cue settings for the scope.
func loadConfigForScope(localOnly bool) (cue.Value, error) {
	paths, err := config.ResolvePaths("")
	if err != nil {
		return cue.Value{}, err
	}

	loader := internalcue.NewLoader()

	var dirs []string
	if localOnly {
		if paths.LocalExists {
			dirs = []string{paths.Local}
		}
	} else {
		dirs = paths.ForScope(config.ScopeMerged)
	}

	if len(dirs) == 0 {
		return cue.Value{}, fmt.Errorf("no config found")
	}

	result, err := loader.Load(dirs)
	if err != nil {
		return cue.Value{}, err
	}

	return result.Value, nil
}

// getDefaultAgentFromConfig extracts default_agent from config value.
func getDefaultAgentFromConfig(cfg cue.Value) string {
	val := cfg.LookupPath(cue.ParsePath("settings.default_agent"))
	if val.Exists() {
		s, _ := val.String()
		return s
	}
	return ""
}

// RoleConfig represents a role configuration for editing.
type RoleConfig struct {
	Name        string
	Description string
	File        string
	Command     string
	Prompt      string
	Tags        []string
	Optional    bool   // If true, skip gracefully when file is missing
	Source      string // "global" or "local" - for display only
	Origin      string // Registry module path when installed from registry
}

// loadRolesForScope loads roles from the appropriate scope.
// Returns the roles map, names in definition order, and any error.
func loadRolesForScope(localOnly bool) (map[string]RoleConfig, []string, error) {
	return loadForScope(localOnly, loadRolesFromDir, func(r *RoleConfig, s string) { r.Source = s })
}

// loadRolesFromDir loads roles from a specific directory.
// Returns the roles map, names in definition order, and any error.
func loadRolesFromDir(dir string) (map[string]RoleConfig, []string, error) {
	roles := make(map[string]RoleConfig)
	var order []string

	loader := internalcue.NewLoader()
	cfg, err := loader.LoadSingle(dir)
	if err != nil {
		// If no CUE files exist, return empty map (not an error)
		if errors.Is(err, internalcue.ErrNoCUEFiles) {
			return roles, order, nil
		}
		return roles, order, err
	}

	rolesVal := cfg.LookupPath(cue.ParsePath(internalcue.KeyRoles))
	if !rolesVal.Exists() {
		return roles, order, nil
	}

	iter, err := rolesVal.Fields()
	if err != nil {
		return nil, nil, fmt.Errorf("iterating roles: %w", err)
	}

	for iter.Next() {
		name := iter.Selector().Unquoted()
		val := iter.Value()

		role := RoleConfig{Name: name}

		if v := val.LookupPath(cue.ParsePath("description")); v.Exists() {
			role.Description, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("file")); v.Exists() {
			role.File, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("command")); v.Exists() {
			role.Command, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("prompt")); v.Exists() {
			role.Prompt, _ = v.String()
		}

		role.Tags = extractTags(val)

		// Load origin (registry provenance)
		if v := val.LookupPath(cue.ParsePath("origin")); v.Exists() {
			role.Origin, _ = v.String()
		}

		// Load optional field
		if v := val.LookupPath(cue.ParsePath("optional")); v.Exists() {
			role.Optional, _ = v.Bool()
		}

		roles[name] = role
		order = append(order, name)
	}

	return roles, order, nil
}

// writeRolesFile writes the roles configuration to a file.
// Fields are written in the provided order.
func writeRolesFile(path string, roles map[string]RoleConfig, order []string) error {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by start config\n")
	sb.WriteString("// Edit this file to customize your role configuration\n\n")
	sb.WriteString("roles: {\n")

	for _, name := range order {
		role := roles[name]
		sb.WriteString(fmt.Sprintf("\t%q: {\n", name))

		// Write origin first if present (registry provenance)
		if role.Origin != "" {
			sb.WriteString(fmt.Sprintf("\t\torigin: %q\n", role.Origin))
		}
		if role.Description != "" {
			sb.WriteString(fmt.Sprintf("\t\tdescription: %q\n", role.Description))
		}
		if role.File != "" {
			sb.WriteString(fmt.Sprintf("\t\tfile: %q\n", role.File))
		}
		if role.Command != "" {
			sb.WriteString(fmt.Sprintf("\t\tcommand: %q\n", role.Command))
		}
		writeCUEPrompt(&sb, role.Prompt)
		writeCUETags(&sb, role.Tags)
		if role.Optional {
			sb.WriteString("\t\toptional: true\n")
		}

		sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// ContextConfig represents a context configuration for editing.
type ContextConfig struct {
	Name        string
	Description string
	File        string
	Command     string
	Prompt      string
	Required    bool
	Default     bool
	Tags        []string
	Source      string // "global" or "local" - for display only
	Origin      string // Registry module path when installed from registry
}

// loadContextsForScope loads contexts from the appropriate scope.
// Returns the contexts map, names in definition order, and any error.
func loadContextsForScope(localOnly bool) (map[string]ContextConfig, []string, error) {
	return loadForScope(localOnly, loadContextsFromDir, func(c *ContextConfig, s string) { c.Source = s })
}

// loadContextsFromDir loads contexts from a specific directory.
// Returns the contexts map, names in definition order, and any error.
func loadContextsFromDir(dir string) (map[string]ContextConfig, []string, error) {
	contexts := make(map[string]ContextConfig)
	var order []string

	loader := internalcue.NewLoader()
	cfg, err := loader.LoadSingle(dir)
	if err != nil {
		// If no CUE files exist, return empty map (not an error)
		if errors.Is(err, internalcue.ErrNoCUEFiles) {
			return contexts, order, nil
		}
		return contexts, order, err
	}

	contextsVal := cfg.LookupPath(cue.ParsePath(internalcue.KeyContexts))
	if !contextsVal.Exists() {
		return contexts, order, nil
	}

	iter, err := contextsVal.Fields()
	if err != nil {
		return nil, nil, fmt.Errorf("iterating contexts: %w", err)
	}

	for iter.Next() {
		name := iter.Selector().Unquoted()
		val := iter.Value()

		ctx := ContextConfig{Name: name}

		if v := val.LookupPath(cue.ParsePath("description")); v.Exists() {
			ctx.Description, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("file")); v.Exists() {
			ctx.File, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("command")); v.Exists() {
			ctx.Command, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("prompt")); v.Exists() {
			ctx.Prompt, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("required")); v.Exists() {
			ctx.Required, _ = v.Bool()
		}
		if v := val.LookupPath(cue.ParsePath("default")); v.Exists() {
			ctx.Default, _ = v.Bool()
		}

		ctx.Tags = extractTags(val)

		// Load origin (registry provenance)
		if v := val.LookupPath(cue.ParsePath("origin")); v.Exists() {
			ctx.Origin, _ = v.String()
		}

		contexts[name] = ctx
		order = append(order, name)
	}

	return contexts, order, nil
}

// writeContextsFile writes the contexts configuration to a file.
// Fields are written in the provided order.
func writeContextsFile(path string, contexts map[string]ContextConfig, order []string) error {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by start config\n")
	sb.WriteString("// Edit this file to customize your context configuration\n\n")
	sb.WriteString("contexts: {\n")

	for _, name := range order {
		ctx := contexts[name]
		sb.WriteString(fmt.Sprintf("\t%q: {\n", name))

		// Write origin first if present (registry provenance)
		if ctx.Origin != "" {
			sb.WriteString(fmt.Sprintf("\t\torigin: %q\n", ctx.Origin))
		}
		if ctx.Description != "" {
			sb.WriteString(fmt.Sprintf("\t\tdescription: %q\n", ctx.Description))
		}
		if ctx.File != "" {
			sb.WriteString(fmt.Sprintf("\t\tfile: %q\n", ctx.File))
		}
		if ctx.Command != "" {
			sb.WriteString(fmt.Sprintf("\t\tcommand: %q\n", ctx.Command))
		}
		writeCUEPrompt(&sb, ctx.Prompt)
		if ctx.Required {
			sb.WriteString("\t\trequired: true\n")
		}
		if ctx.Default {
			sb.WriteString("\t\tdefault: true\n")
		}
		writeCUETags(&sb, ctx.Tags)

		sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// TaskConfig represents a task configuration for editing.
type TaskConfig struct {
	Name        string
	Description string
	File        string
	Command     string
	Prompt      string
	Role        string
	Tags        []string
	Source      string // "global" or "local" - for display only
	Origin      string // Registry module path when installed from registry
}

// loadTasksForScope loads tasks from the appropriate scope.
// Returns the tasks map, names in definition order, and any error.
func loadTasksForScope(localOnly bool) (map[string]TaskConfig, []string, error) {
	return loadForScope(localOnly, loadTasksFromDir, func(t *TaskConfig, s string) { t.Source = s })
}

// loadTasksFromDir loads tasks from a specific directory.
// Returns the tasks map, names in definition order, and any error.
func loadTasksFromDir(dir string) (map[string]TaskConfig, []string, error) {
	tasks := make(map[string]TaskConfig)
	var order []string

	loader := internalcue.NewLoader()
	cfg, err := loader.LoadSingle(dir)
	if err != nil {
		// If no CUE files exist, return empty map (not an error)
		if errors.Is(err, internalcue.ErrNoCUEFiles) {
			return tasks, order, nil
		}
		return tasks, order, err
	}

	tasksVal := cfg.LookupPath(cue.ParsePath(internalcue.KeyTasks))
	if !tasksVal.Exists() {
		return tasks, order, nil
	}

	iter, err := tasksVal.Fields()
	if err != nil {
		return nil, nil, fmt.Errorf("iterating tasks: %w", err)
	}

	for iter.Next() {
		name := iter.Selector().Unquoted()
		val := iter.Value()

		task := TaskConfig{Name: name}

		if v := val.LookupPath(cue.ParsePath("description")); v.Exists() {
			task.Description, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("file")); v.Exists() {
			task.File, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("command")); v.Exists() {
			task.Command, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("prompt")); v.Exists() {
			task.Prompt, _ = v.String()
		}
		if v := val.LookupPath(cue.ParsePath("role")); v.Exists() {
			task.Role, _ = v.String()
		}

		task.Tags = extractTags(val)

		// Load origin (registry provenance)
		if v := val.LookupPath(cue.ParsePath("origin")); v.Exists() {
			task.Origin, _ = v.String()
		}

		tasks[name] = task
		order = append(order, name)
	}

	return tasks, order, nil
}

// writeTasksFile writes the tasks configuration to a file.
// Tasks are not order-dependent, so names are sorted alphabetically for consistent output.
func writeTasksFile(path string, tasks map[string]TaskConfig) error {
	var sb strings.Builder

	sb.WriteString("// Auto-generated by start config\n")
	sb.WriteString("// Edit this file to customize your task configuration\n\n")
	sb.WriteString("tasks: {\n")

	// Sort task names for consistent output
	var names []string
	for name := range tasks {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		task := tasks[name]
		sb.WriteString(fmt.Sprintf("\t%q: {\n", name))

		// Write origin first if present (registry provenance)
		if task.Origin != "" {
			sb.WriteString(fmt.Sprintf("\t\torigin: %q\n", task.Origin))
		}
		if task.Description != "" {
			sb.WriteString(fmt.Sprintf("\t\tdescription: %q\n", task.Description))
		}
		if task.File != "" {
			sb.WriteString(fmt.Sprintf("\t\tfile: %q\n", task.File))
		}
		if task.Command != "" {
			sb.WriteString(fmt.Sprintf("\t\tcommand: %q\n", task.Command))
		}
		writeCUEPrompt(&sb, task.Prompt)
		if task.Role != "" {
			sb.WriteString(fmt.Sprintf("\t\trole: %q\n", task.Role))
		}
		writeCUETags(&sb, task.Tags)

		sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")

	return os.WriteFile(path, []byte(sb.String()), 0644)
}
